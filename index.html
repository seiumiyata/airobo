<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust & Circuit - Ver.3.2 Tactician</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050505;
            color: #a0a0a0;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            overflow: hidden;
        }
        .tech-font {
            font-family: 'Share Tech Mono', monospace;
        }
        /* CRT Scanline */
        .scanline {
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.15) 50%,
                rgba(0,0,0,0.15)
            );
            background-size: 100% 3px;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 50;
        }
        .glow-text {
            text-shadow: 0 0 5px currentColor;
        }
        /* Custom Scrollbar for Logs */
        .log-scroll::-webkit-scrollbar { width: 4px; }
        .log-scroll::-webkit-scrollbar-track { background: #000; }
        .log-scroll::-webkit-scrollbar-thumb { background: #00ffcc; }
        
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        .blink { animation: blink 1s infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Game Data (Rebalanced) ---
        const PARTS_DB = {
            head: [
                { id: 'h_junk', name: 'JUNK-EYE', weight: 10, enCost: 5, scan: 50, desc: '視界不良だが軽い。' },
                { id: 'h_sniper', name: 'EAGLE-X', weight: 15, enCost: 20, scan: 120, desc: '長距離FCS。遠距離命中UP。' },
                { id: 'h_cqc', name: 'BULL-HORN', weight: 25, enCost: 10, scan: 60, ap: 300, desc: '重装甲ヘッド。AP高。' },
            ],
            core: [
                { id: 'c_std', name: 'STD-DIESEL', weight: 100, enOutput: 100, ap: 1000, cooling: 50, desc: '標準型。' },
                { id: 'c_light', name: 'RACING-V', weight: 60, enOutput: 140, ap: 600, cooling: 40, desc: '高出力・低耐久。' },
                { id: 'c_heavy', name: 'FORTRESS-G', weight: 200, enOutput: 90, ap: 2200, cooling: 80, desc: '超重装甲要塞。' },
            ],
            arms: [
                { id: 'a_std', name: 'MANIPULATOR', weight: 50, enCost: 10, aim: 100, melee: 100, desc: '標準アーム。' },
                { id: 'a_gunner', name: 'GUNNER-II', weight: 60, enCost: 25, aim: 160, melee: 50, desc: '射撃特化。命中率大。' },
                { id: 'a_power', name: 'OGRE-FIST', weight: 90, enCost: 30, aim: 70, melee: 200, desc: '格闘特化。近接威力倍増。' },
            ],
            legs: [
                { id: 'l_biped', name: 'BIPED-01', type: 'Biped', weight: 100, load: 600, speed: 60, ap: 800, evasion: 10, desc: '標準二脚。' },
                { id: 'l_reverse', name: 'LOCUST-R', type: 'Reverse', weight: 70, load: 450, speed: 100, ap: 500, evasion: 40, desc: '高機動逆関節。速い。' },
                { id: 'l_tank', name: 'G-TREAD', type: 'Tank', weight: 300, load: 1200, speed: 30, ap: 2500, evasion: 0, desc: '鈍重だが堅牢なタンク。' },
            ],
            weapon: [
                // Rebalanced: Heavy weapons hit harder but slower. Speed matters.
                { id: 'w_mg', name: 'MACHINE GUN', weight: 30, range: 200, power: 12, reload: 4, speed: 20, type: 'KINETIC', accuracy: 65, stability: 40, desc: '弾幕形成用。DPSは高い。' },
                { id: 'w_rifle', name: 'ASSAULT RIFLE', weight: 40, range: 400, power: 45, reload: 25, speed: 25, type: 'KINETIC', accuracy: 85, stability: 80, desc: '中距離のスタンダード。' },
                { id: 'w_sniper', name: 'RAIL CANNON', weight: 80, range: 800, power: 180, reload: 120, speed: 60, type: 'KINETIC', accuracy: 98, stability: 95, desc: '超遠距離・高威力・長リロード。' },
                { id: 'w_laser', name: 'LASER RIFLE', weight: 50, range: 500, power: 70, reload: 45, speed: 40, enUse: 35, type: 'ENERGY', accuracy: 92, stability: 90, desc: '高精度エネルギー兵器。' },
                { id: 'w_blade', name: 'PLASMA BLADE', weight: 20, range: 80, power: 400, reload: 50, speed: 0, enUse: 20, type: 'MELEE', accuracy: 100, stability: 50, desc: '必殺の近接兵器。' },
            ]
        };

        const RANKS = [
            { id: 'F', name: 'F-RANK', prize: 1000, enemyId: 'enemy_f' },
            { id: 'D', name: 'D-RANK', prize: 3000, enemyId: 'enemy_d' },
            { id: 'B', name: 'B-RANK', prize: 8000, enemyId: 'enemy_b' },
            { id: 'S', name: 'S-RANK', prize: 50000, enemyId: 'enemy_s' },
        ];

        const ENEMIES = {
            'enemy_f': { name: 'Scrap Walker', color: '#ff6600', parts: { head: PARTS_DB.head[0], core: PARTS_DB.core[0], arms: PARTS_DB.arms[0], legs: PARTS_DB.legs[0], weapon: PARTS_DB.weapon[0] }, ai: { range: 20, aggression: 90, evasion: 10 } },
            'enemy_d': { name: 'Iron Turtle', color: '#00cc66', parts: { head: PARTS_DB.head[0], core: PARTS_DB.core[2], arms: PARTS_DB.arms[0], legs: PARTS_DB.legs[2], weapon: PARTS_DB.weapon[1] }, ai: { range: 60, aggression: 40, evasion: 0 } },
            'enemy_b': { name: 'Desert Fox', color: '#cc33cc', parts: { head: PARTS_DB.head[1], core: PARTS_DB.core[1], arms: PARTS_DB.arms[1], legs: PARTS_DB.legs[1], weapon: PARTS_DB.weapon[2] }, ai: { range: 90, aggression: 30, evasion: 90 } },
            'enemy_s': { name: 'CRIMSON AI', color: '#ff0000', parts: { head: PARTS_DB.head[2], core: PARTS_DB.core[1], arms: PARTS_DB.arms[2], legs: PARTS_DB.legs[1], weapon: PARTS_DB.weapon[3] }, ai: { range: 50, aggression: 100, evasion: 80 } },
        };

        // --- Live Commentary Data ---
        const COMMENTARY = {
            START: ["「さあ、バトルの時間だ！ 両機、起動シーケンス完了！」", "「フィールドに緊張が走る！ 生き残るのはどちらだ！？」", "「賭け率は拮抗しているぞ！ さあ始めよう！」"],
            CLOSE_IN: ["「おっと、一気に距離を詰めた！ 近接戦を仕掛ける気か！？」", "「肉薄する！ ぶつかり合うぞ！」"],
            RETREAT: ["「距離を取った！ 射撃戦に持ち込む構えだ！」", "「一度引いて体勢を立て直す判断か！」"],
            HIT_SMALL: ["「当たったが浅い！ まだ装甲は健在だ！」", "「牽制射撃がヒット！」"],
            HIT_BIG: ["「直撃ぃぃ！！ 装甲が吹き飛んだぞ！！」", "「強烈な一撃が入った！ これは痛い！」", "「クリティカルヒット！ 機体バランスが崩れる！」"],
            MISS: ["「かわした！ 素晴らしい反応速度だ！」", "「当たらない！ 照準が甘いぞ！」"],
            RELOAD: ["「弾切れか！？ 今は隙だらけだぞ！」", "「リロード中！ 耐え凌げるか！？」"],
            LOW_AP: ["「もう後がない！ 装甲値がレッドゾーンだ！」", "「煙が出ているぞ！ いつの間にか瀕死だ！」"],
            WIN: ["「勝負あり！！ 立っていたのは勝者のみだ！」", "「圧倒的じゃないか！ 素晴らしい勝利だ！」"],
            LOSE: ["「シグナルロスト……。残念ながらスクラップ行きだ。」", "「勝負は非情だ。次の挑戦に期待しよう。」"]
        };

        // --- Common UI ---
        const Button = ({ onClick, children, className = '', disabled = false, variant = 'primary' }) => {
            const baseStyle = "px-4 py-2 tech-font font-bold transition-all duration-200 border transform active:scale-95 disabled:opacity-50 ";
            const variants = {
                primary: "bg-cyan-950/40 border-cyan-500 text-cyan-400 hover:bg-cyan-900/60 hover:shadow-[0_0_15px_rgba(34,211,238,0.4)]",
                secondary: "bg-gray-900/40 border-gray-600 text-gray-400 hover:bg-gray-800",
            };
            return <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`}>{children}</button>;
        };

        const Slider = ({ label, value, min, max, onChange, leftLabel, rightLabel }) => (
            <div className="mb-6">
                <div className="flex justify-between mb-1 tech-font text-sm">
                    <span className="text-gray-500">{leftLabel}</span>
                    <span className="text-cyan-400 glow-text">{label} [{value}]</span>
                    <span className="text-gray-500">{rightLabel}</span>
                </div>
                <input type="range" min={min} max={max} value={value} onChange={(e) => onChange(Number(e.target.value))} className="w-full h-1 bg-gray-800 appearance-none cursor-pointer accent-cyan-500" />
            </div>
        );

        // --- Assembly ---
        const AssembleScreen = ({ currentParts, setPart, onBack }) => {
            const [selectedSlot, setSelectedSlot] = useState('head');
            const [hoveredPart, setHoveredPart] = useState(null);

            const calculateStats = (parts) => {
                const totalWeight = Object.values(parts).reduce((sum, p) => sum + p.weight, 0);
                const totalAP = (parts.head.ap||0) + parts.core.ap + parts.legs.ap;
                const maxLoad = parts.legs.load;
                const speed = Math.max(10, parts.legs.speed - Math.max(0, (totalWeight - maxLoad) / 2)); // Penalty logic
                const totalAccuracy = parts.weapon.accuracy + (parts.arms.aim - 100);
                const meleePower = parts.weapon.type === 'MELEE' ? parts.weapon.power * (parts.arms.melee / 100) : 0;
                return { totalWeight, maxLoad, totalAP, speed, totalAccuracy, meleePower };
            };

            const currentStats = useMemo(() => calculateStats(currentParts), [currentParts]);
            const previewStats = useMemo(() => hoveredPart ? calculateStats({ ...currentParts, [selectedSlot]: hoveredPart }) : currentStats, [currentParts, hoveredPart, selectedSlot, currentStats]);

            const StatRow = ({ label, current, preview, isBadHigh = false }) => {
                const diff = preview - current;
                let color = diff > 0 ? (isBadHigh ? 'text-red-400' : 'text-cyan-400') : (isBadHigh ? 'text-cyan-400' : 'text-red-400');
                if (diff === 0) color = 'text-gray-500';
                return (
                    <div className="flex justify-between py-1 border-b border-gray-800 text-sm">
                        <span className="text-gray-500">{label}</span>
                        <div className="flex gap-2 font-mono"><span className="text-white">{current}</span>{diff !== 0 && <span className={color}>{diff>0?'▲':'▼'}{Math.abs(diff)}</span>}</div>
                    </div>
                );
            };

            return (
                <div className="flex flex-col h-full p-4 bg-gray-950">
                    <div className="flex justify-between items-center mb-4 border-b border-gray-800 pb-2"><h2 className="text-2xl tech-font text-cyan-500">ASSEMBLY</h2><Button onClick={onBack} variant="secondary">BACK</Button></div>
                    <div className="flex flex-1 gap-4 overflow-hidden">
                        <div className="w-1/4 flex flex-col gap-2">{['head', 'core', 'arms', 'legs', 'weapon'].map(slot => (
                            <button key={slot} onClick={() => setSelectedSlot(slot)} className={`p-3 text-left border ${selectedSlot===slot?'border-cyan-500 bg-cyan-900/30':'border-gray-700 hover:bg-gray-800'}`}><div className="text-xs text-gray-500 uppercase">{slot}</div><div className="text-sm font-bold text-gray-300 truncate">{currentParts[slot].name}</div></button>
                        ))}</div>
                        <div className="w-1/2 overflow-y-auto pr-2 custom-scrollbar bg-black/30 border border-gray-800">
                            {(selectedSlot==='weapon'?PARTS_DB.weapon:PARTS_DB[selectedSlot]).map(part => (
                                <div key={part.id} onClick={()=>setPart(selectedSlot, part)} onMouseEnter={()=>setHoveredPart(part)} onMouseLeave={()=>setHoveredPart(null)} className={`p-3 border-b border-gray-800 cursor-pointer hover:bg-gray-800 ${currentParts[selectedSlot].id===part.id?'bg-cyan-900/20 border-l-4 border-l-cyan-500':''}`}>
                                    <div className="flex justify-between"><span className="font-bold text-gray-200">{part.name}</span><span className="text-xs text-gray-500">WT:{part.weight}</span></div>
                                    <div className="text-xs text-gray-500 mt-1">{part.desc}</div>
                                </div>
                            ))}
                        </div>
                        <div className="w-1/4 p-4 border border-gray-800 bg-black/50">
                            <h3 className="text-cyan-500 tech-font mb-4">STATS</h3>
                            <StatRow label="AP (HP)" current={currentStats.totalAP} preview={previewStats.totalAP} />
                            <StatRow label="WEIGHT" current={currentStats.totalWeight} preview={previewStats.totalWeight} isBadHigh />
                            <StatRow label="SPEED" current={Math.floor(currentStats.speed)} preview={Math.floor(previewStats.speed)} />
                            <StatRow label="ACCURACY" current={Math.floor(currentStats.totalAccuracy)} preview={Math.floor(previewStats.totalAccuracy)} />
                            {currentStats.meleePower > 0 && <StatRow label="MELEE ATK" current={Math.floor(currentStats.meleePower)} preview={Math.floor(previewStats.meleePower)} />}
                            {currentStats.totalWeight > currentStats.maxLoad && <div className="mt-4 p-2 bg-red-900/50 border border-red-500 text-red-200 text-xs text-center blink">OVERWEIGHT! SPEED DOWN</div>}
                        </div>
                    </div>
                </div>
            );
        };

        const TacticsScreen = ({ aiSettings, setAiSettings, onBack }) => (
            <div className="flex flex-col h-full p-8 max-w-3xl mx-auto justify-center">
                <h2 className="text-4xl text-center tech-font text-cyan-500 glow-text mb-8">AI LOGIC TUNING</h2>
                <div className="border border-gray-800 p-10 bg-black/40 backdrop-blur space-y-8">
                    <Slider label="ENGAGEMENT RANGE" value={aiSettings.range} min={0} max={100} onChange={(v)=>setAiSettings({...aiSettings, range: v})} leftLabel="CLOSE [近接]" rightLabel="FAR [遠距離]" />
                    <Slider label="AGGRESSION LEVEL" value={aiSettings.aggression} min={0} max={100} onChange={(v)=>setAiSettings({...aiSettings, aggression: v})} leftLabel="DEFENSIVE [慎重]" rightLabel="OFFENSIVE [好戦]" />
                    <Slider label="EVASION PROTOCOL" value={aiSettings.evasion} min={0} max={100} onChange={(v)=>setAiSettings({...aiSettings, evasion: v})} leftLabel="DURABILITY [装甲]" rightLabel="MOBILITY [回避]" />
                </div>
                <div className="mt-12 text-center"><Button onClick={onBack} className="w-64">CONFIRM</Button></div>
            </div>
        );

        // --- Battle ---
        const BattleScreen = ({ playerParts, playerAi, enemyData, onFinish }) => {
            const canvasRef = useRef(null);
            const [logs, setLogs] = useState([]);
            const [liveComment, setLiveComment] = useState("");
            const [battleState, setBattleState] = useState(null);
            const [viewMode, setViewMode] = useState('TPS'); // Default to Top-Down (TPS)

            // Random Commentary Helper
            const say = (type) => {
                const list = COMMENTARY[type] || COMMENTARY.START;
                const text = list[Math.floor(Math.random() * list.length)];
                setLiveComment(text);
                setLogs(prev => [`[LIVE] ${text}`, ...prev].slice(0, 30));
            };

            useEffect(() => {
                const initMech = (parts, ai, isPlayer, name, color) => {
                    const totalWeight = Object.values(parts).reduce((sum, p) => sum + (p.weight||0), 0);
                    const weightPenalty = Math.max(0, (totalWeight - parts.legs.load) / 2);
                    const baseSpeed = parts.legs.speed - weightPenalty;
                    const armAimBonus = parts.arms.aim || 100;
                    const meleeBonus = parts.arms.melee || 100;
                    
                    return {
                        isPlayer, name, color,
                        maxHp: (parts.head.ap||0) + parts.core.ap + parts.legs.ap,
                        hp: (parts.head.ap||0) + parts.core.ap + parts.legs.ap,
                        en: parts.core.enOutput, maxEn: parts.core.enOutput,
                        enRecovery: parts.core.enOutput / 15,
                        speed: Math.max(5, baseSpeed / 5), // Movement speed px/frame
                        evasionBase: parts.legs.evasion || 0,
                        accuracyStat: parts.weapon.accuracy * (armAimBonus / 100),
                        meleePower: (parts.weapon.type === 'MELEE' ? parts.weapon.power : 10) * (meleeBonus / 100),
                        weapon: parts.weapon, parts, ai,
                        x: isPlayer ? 400 : 400, // Center X
                        y: isPlayer ? 550 : 50,  // Top/Bottom start for Top-Down
                        targetDist: (ai.range / 100) * 600 + 50,
                        cooldown: 0, recoil: 0, moveState: 0,
                    };
                };

                setBattleState({
                    player: initMech(playerParts, playerAi, true, 'PLAYER', '#00ffcc'),
                    enemy: initMech(enemyData.parts, enemyData.ai, false, enemyData.name, enemyData.color),
                    bullets: [], effects: [], frame: 0, finished: false, cameraShake: {x:0, y:0}, damageFlash: 0
                });
                say('START');
            }, []);

            useEffect(() => {
                if (!battleState || battleState.finished) return;
                const interval = setInterval(() => {
                    setBattleState(prev => {
                        if (prev.finished) return prev;
                        const next = { ...prev, frame: prev.frame + 1 };
                        next.bullets = [...prev.bullets];
                        next.effects = [...prev.effects];
                        next.cameraShake = {x: prev.cameraShake.x * 0.8, y: prev.cameraShake.y * 0.8}; 
                        
                        const p = next.player;
                        const e = next.enemy;
                        const dist = Math.sqrt((p.x - e.x)**2 + (p.y - e.y)**2);

                        // Logic for both Mechs
                        [p, e].forEach(mech => {
                            const target = mech.isPlayer ? e : p;
                            if (mech.hp <= 0) return;

                            // EN Regen
                            mech.en = Math.min(mech.maxEn, mech.en + mech.enRecovery * 0.1);
                            if (mech.cooldown > 0) mech.cooldown--;
                            if (mech.recoil > 0) mech.recoil *= 0.8;

                            // --- AI MOVEMENT ---
                            const rangeDiff = dist - mech.targetDist;
                            const speed = mech.speed * (mech.en > 10 ? 1 : 0.5); // Slow if low EN
                            
                            // Move logic (Top Down 2D)
                            const angle = Math.atan2(target.y - mech.y, target.x - mech.x);
                            
                            // 1. Distance Control (Forward/Back)
                            let moveX = 0, moveY = 0;
                            if (rangeDiff > 50) { // Too far, close in
                                moveX += Math.cos(angle) * speed * 0.8;
                                moveY += Math.sin(angle) * speed * 0.8;
                            } else if (rangeDiff < -50) { // Too close, retreat
                                moveX -= Math.cos(angle) * speed; // Back away faster
                                moveY -= Math.sin(angle) * speed;
                            }

                            // 2. Strafing (Sideways) - Randomized
                            mech.moveState += 0.05;
                            const strafeDir = Math.sin(mech.moveState + (mech.isPlayer?0:10)) > 0 ? 1 : -1;
                            // Strafe perpendicular to angle
                            moveX += Math.cos(angle + Math.PI/2 * strafeDir) * speed * 0.5;
                            moveY += Math.sin(angle + Math.PI/2 * strafeDir) * speed * 0.5;

                            // Apply
                            mech.x += moveX;
                            mech.y += moveY;

                            // Clamp Bounds (800x600 arena)
                            mech.x = Math.max(50, Math.min(750, mech.x));
                            mech.y = Math.max(50, Math.min(550, mech.y));

                            // --- ATTACK ---
                            const w = mech.weapon;
                            const canFire = mech.cooldown <= 0 && mech.en >= (w.enUse||0);
                            // Shot angle variance
                            const aimError = (100 - mech.accuracyStat) * 0.005; 
                            
                            if (canFire && dist <= w.range + 100) {
                                // Aggression check
                                if (Math.random() < (mech.ai.aggression/100) || dist < 100) {
                                    if(w.enUse) mech.en -= w.enUse;
                                    mech.cooldown = w.reload;
                                    mech.recoil = 20;

                                    if (w.type === 'MELEE' && dist < 120) {
                                        // Melee Hitscan
                                        next.effects.push({x: target.x, y: target.y, text: "SLASH!", color: "#fff", life: 10});
                                        // Guaranteed hit if close enough?
                                        const dmg = Math.floor(mech.meleePower * (0.8 + Math.random()*0.4));
                                        target.hp -= dmg;
                                        next.effects.push({x: target.x, y: target.y-40, text: `-${dmg}`, color: 'red', life: 30});
                                        if (dmg > 200) say('HIT_BIG');
                                    } else {
                                        // Projectile
                                        const shotAngle = angle + (Math.random() * aimError - aimError/2);
                                        next.bullets.push({
                                            owner: mech.isPlayer ? 'player' : 'enemy',
                                            x: mech.x, y: mech.y,
                                            vx: Math.cos(shotAngle) * w.speed,
                                            vy: Math.sin(shotAngle) * w.speed,
                                            damage: w.power,
                                            life: 100, // frames
                                            color: mech.isPlayer ? '#00ffcc' : '#ff3333'
                                        });
                                    }
                                }
                            }
                        });

                        // Bullet Physics
                        next.bullets = next.bullets.filter(b => {
                            b.x += b.vx;
                            b.y += b.vy;
                            b.life--;
                            
                            // Hit Check
                            const target = b.owner === 'player' ? e : p;
                            const hitDist = Math.sqrt((b.x - target.x)**2 + (b.y - target.y)**2);
                            
                            if (hitDist < 30) {
                                // Evasion Check
                                const evasion = (target.evasionBase + (target.ai.evasion/5));
                                if (Math.random() * 100 < evasion && target.en > 10) {
                                    // Dodged
                                    target.en -= 10; // Evasion costs EN
                                    next.effects.push({x: target.x, y: target.y-30, text: "AVOID", color: "#888", life: 20});
                                    if(Math.random()<0.1) say('MISS');
                                    return false; 
                                }
                                
                                // Hit
                                target.hp -= b.damage;
                                next.effects.push({x: target.x, y: target.y-20, text: `-${b.damage}`, color: b.color, life: 30});
                                
                                if (target.isPlayer) {
                                    next.cameraShake = {x: Math.random()*10-5, y: Math.random()*10-5};
                                    next.damageFlash = 5;
                                }
                                if(target.hp < target.maxHp*0.3 && Math.random()<0.1) say('LOW_AP');
                                if(b.damage > 100 && Math.random()<0.2) say('HIT_BIG');

                                return false; 
                            }
                            return b.life > 0;
                        });

                        next.effects = next.effects.filter(e => e.life-- > 0);
                        if (next.damageFlash > 0) next.damageFlash--;

                        if (p.hp <= 0 || e.hp <= 0) {
                            next.finished = true;
                            say(p.hp > 0 ? 'WIN' : 'LOSE');
                            setTimeout(() => onFinish(p.hp > 0), 3000);
                        }
                        return next;
                    });
                }, 1000/30);
                return () => clearInterval(interval);
            }, [battleState, onFinish]);

            // --- Drawing ---
            const drawScene = (ctx) => {
                if (!battleState) return;
                const { player, enemy, bullets, effects, cameraShake, damageFlash } = battleState;
                const w = ctx.canvas.width; const h = ctx.canvas.height;

                ctx.save();
                ctx.translate(cameraShake.x, cameraShake.y);
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, w, h);

                if (viewMode === 'TPS') { // Top Down View
                    // Grid
                    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
                    ctx.beginPath();
                    for(let i=0; i<=w; i+=100) { ctx.moveTo(i,0); ctx.lineTo(i,h); }
                    for(let i=0; i<=h; i+=100) { ctx.moveTo(0,i); ctx.lineTo(w,i); }
                    ctx.stroke();

                    // Draw Mechs Top Down
                    const drawTopDown = (mech) => {
                        if (mech.hp<=0) return;
                        ctx.save();
                        ctx.translate(mech.x, mech.y);
                        // Rotate towards enemy
                        const target = mech.isPlayer ? enemy : player;
                        const angle = Math.atan2(target.y - mech.y, target.x - mech.x);
                        ctx.rotate(angle);

                        ctx.fillStyle = '#000'; ctx.strokeStyle = mech.color; ctx.lineWidth = 2;
                        
                        // Body
                        ctx.beginPath();
                        ctx.moveTo(15, 0); ctx.lineTo(-10, 15); ctx.lineTo(-10, -15); ctx.closePath();
                        ctx.fill(); ctx.stroke();
                        
                        // Arms/Weapons
                        ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(10, 25); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(10, -25); ctx.stroke();

                        // HP Arc
                        ctx.strokeStyle = mech.isPlayer ? '#00ffcc' : '#ff3333';
                        ctx.beginPath(); ctx.arc(0, 0, 30, -Math.PI/2, -Math.PI/2 + (Math.PI*2 * (mech.hp/mech.maxHp))); ctx.stroke();
                        
                        ctx.restore();
                        
                        // Label
                        ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.textAlign='center';
                        ctx.fillText(mech.name, mech.x, mech.y - 40);
                    };

                    drawTopDown(player);
                    drawTopDown(enemy);

                    // HUD: Compare Stats (Top)
                    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(100, 10, 600, 60);
                    ctx.strokeStyle = '#333'; ctx.strokeRect(100, 10, 600, 60);
                    
                    const drawBar = (x, val, max, col, label) => {
                        ctx.fillStyle = col; ctx.font = '12px "Share Tech Mono"'; ctx.textAlign = 'left';
                        ctx.fillText(label, x, 30);
                        ctx.fillStyle = '#333'; ctx.fillRect(x, 35, 100, 8);
                        ctx.fillStyle = col; ctx.fillRect(x, 35, 100 * (val/max), 8);
                        ctx.fillText(Math.floor(val), x + 110, 42);
                    };
                    
                    drawBar(120, player.hp, player.maxHp, '#00ffcc', 'P: ARMOR');
                    drawBar(250, player.en, player.maxEn, 'yellow', 'P: ENERGY');
                    
                    drawBar(450, enemy.hp, enemy.maxHp, '#ff3333', 'E: ARMOR');
                    drawBar(580, enemy.en, enemy.maxEn, 'orange', 'E: ENERGY');

                } else { // FPS View
                    const dist = Math.sqrt((player.x - enemy.x)**2 + (player.y - enemy.y)**2);
                    const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    
                    // Simple "Facing" logic: Enemy is centered if we look at them.
                    // Let's pretend player always faces enemy in FPS for simplicity, or simulate turning?
                    // For "Gunner" feel, let's keep enemy centered but scale by distance.
                    
                    const scale = 1000 / (dist + 200);
                    
                    // Grid Floor (Pseudo 3D)
                    ctx.strokeStyle = '#1a1a1a'; ctx.lineWidth = 1;
                    ctx.beginPath();
                    for(let i=0; i<10; i++) {
                        const y = 300 + (i*i*2);
                        if(y<600) { ctx.moveTo(0, y); ctx.lineTo(800, y); }
                    }
                    ctx.moveTo(400, 300); ctx.lineTo(0, 600);
                    ctx.moveTo(400, 300); ctx.lineTo(800, 600);
                    ctx.stroke();

                    // Enemy Wireframe
                    if (enemy.hp > 0) {
                        ctx.save();
                        ctx.translate(400, 300 + (player.parts.legs.type==='Tank'?20:0)); 
                        ctx.scale(scale, scale);
                        ctx.strokeStyle = '#ff3333'; ctx.lineWidth = 2;
                        
                        // Simple Mech Shape
                        ctx.strokeRect(-20, -60, 40, 40); // Body
                        ctx.strokeRect(-30, -20, 10, 60); // L Leg
                        ctx.strokeRect(20, -20, 10, 60);  // R Leg
                        ctx.strokeRect(-35, -50, 10, 30); // L Arm
                        ctx.strokeRect(25, -50, 10, 30);  // R Arm
                        ctx.strokeRect(-10, -75, 20, 15); // Head
                        
                        // HP Bar above head
                        ctx.fillStyle = 'red'; ctx.fillRect(-30, -90, 60, 5);
                        ctx.fillStyle = '#0f0'; ctx.fillRect(-30, -90, 60 * (enemy.hp/enemy.maxHp), 5);
                        
                        ctx.restore();
                    }

                    // FPS HUD
                    // Reticle
                    ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(400, 300, 50, 0, Math.PI*2); ctx.stroke();
                    ctx.moveTo(380, 300); ctx.lineTo(420, 300); ctx.moveTo(400, 280); ctx.lineTo(400, 320); ctx.stroke();
                    
                    // Status Panels
                    ctx.fillStyle = 'rgba(0, 20, 20, 0.8)';
                    ctx.fillRect(20, 450, 200, 130);
                    ctx.strokeStyle = '#00ffcc'; ctx.strokeRect(20, 450, 200, 130);
                    
                    ctx.fillStyle = '#00ffcc'; ctx.font = '16px "Share Tech Mono"';
                    ctx.fillText("STATUS CHECK", 30, 470);
                    ctx.font = '12px "Share Tech Mono"';
                    ctx.fillText(`AP: ${Math.floor(player.hp)} / ${player.maxHp}`, 30, 490);
                    ctx.fillText(`EN: ${Math.floor(player.en)} / ${player.maxEn}`, 30, 510);
                    ctx.fillText(`WPN: ${player.weapon.name}`, 30, 530);
                    const ammo = player.cooldown > 0 ? "RELOADING..." : "READY";
                    ctx.fillText(`STS: ${ammo}`, 30, 550);

                    // Enemy Info (Right)
                    ctx.fillStyle = 'rgba(20, 0, 0, 0.8)';
                    ctx.fillRect(580, 450, 200, 130);
                    ctx.strokeStyle = '#ff3333'; ctx.strokeRect(580, 450, 200, 130);
                    
                    ctx.fillStyle = '#ff3333'; ctx.font = '16px "Share Tech Mono"';
                    ctx.fillText("TARGET INFO", 590, 470);
                    ctx.font = '12px "Share Tech Mono"';
                    if (enemy.hp > 0) {
                        ctx.fillText(`ID: ${enemy.name}`, 590, 490);
                        ctx.fillText(`DIST: ${Math.floor(dist)}`, 590, 510);
                        ctx.fillText(`AP: ${Math.floor(enemy.hp)}`, 590, 530);
                        ctx.fillText(`WPN: ${enemy.parts.weapon.name}`, 590, 550);
                    } else {
                        ctx.fillText("NO SIGNAL", 590, 490);
                    }
                }

                // Bullets
                bullets.forEach(b => {
                    ctx.fillStyle = b.color;
                    let bx, by;
                    if (viewMode === 'TPS') {
                        bx = b.x; by = b.y;
                        ctx.beginPath(); ctx.arc(bx, by, 3, 0, Math.PI*2); ctx.fill();
                    } else {
                        // FPS Projection (Simplified)
                        // If firing away, start center, go to enemy
                        // If firing at us, start center, get bigger? 
                        // Just random sparks for now to keep it simple
                        if (Math.random() < 0.5) return; // flicker
                        const sx = 400 + (Math.random()*100 - 50);
                        const sy = 300 + (Math.random()*100 - 50);
                        ctx.fillRect(sx, sy, 4, 4);
                    }
                });

                // Effects
                effects.forEach(e => {
                    ctx.fillStyle = e.color; ctx.font = '12px sans-serif';
                    let ex = e.x, ey = e.y;
                    if (viewMode === 'FPS') {
                        // Center effects roughly
                        ex = 400 + (Math.random()*40-20);
                        ey = 300 + (Math.random()*40-20);
                    }
                    ctx.fillText(e.text, ex, ey);
                });

                // Flash
                if (damageFlash > 0) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${damageFlash * 0.1})`;
                    ctx.fillRect(0, 0, w, h);
                }

                ctx.restore();
            };

            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) drawScene(ctx);
            }, [battleState, viewMode]);

            return (
                <div className="w-full h-full bg-black relative flex flex-col">
                    {/* Header / Commentary */}
                    <div className="h-16 bg-gray-900 border-b border-gray-700 flex items-center px-4 justify-between relative overflow-hidden">
                        <div className="flex flex-col z-10">
                            <span className="text-cyan-500 tech-font text-xs">LIVE COMMENTARY</span>
                            <span className="text-white tech-font text-lg crt-flicker">{liveComment}</span>
                        </div>
                        <div className="z-10">
                            <Button onClick={()=>setViewMode(v => v==='FPS'?'TPS':'FPS')}>{viewMode} VIEW [V]</Button>
                        </div>
                        <div className="scanline absolute inset-0"></div>
                    </div>

                    {/* Canvas */}
                    <div className="flex-1 relative">
                        <canvas ref={canvasRef} width={800} height={600} className="w-full h-full object-contain bg-black" />
                        <div className="absolute inset-0 pointer-events-none scanline"></div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [view, setView] = useState('HOME');
            const [currentParts, setCurrentParts] = useState({ head: PARTS_DB.head[0], core: PARTS_DB.core[0], arms: PARTS_DB.arms[0], legs: PARTS_DB.legs[0], weapon: PARTS_DB.weapon[0] });
            const [aiSettings, setAiSettings] = useState({ range: 50, aggression: 50, evasion: 50 });
            const [selectedRank, setSelectedRank] = useState(null);
            const [lastResult, setLastResult] = useState(null);
            const handleFinish = (win) => { setLastResult(win); setView('RESULT'); };

            return (
                <div className="w-screen h-screen flex flex-col text-gray-300 bg-gray-950">
                    <main className="flex-1 overflow-hidden relative">
                        {view === 'HOME' && (
                            <div className="flex flex-col items-center justify-center h-full space-y-8 bg-gray-900">
                                <h1 className="text-6xl tech-font text-cyan-600 glow-text mb-4">RUST & CIRCUIT</h1>
                                <div className="flex flex-col gap-4">
                                    <Button className="w-64 py-4 text-xl" onClick={() => setView('ASSEMBLE')}>ASSEMBLE</Button>
                                    <Button className="w-64 py-4 text-xl" onClick={() => setView('TACTICS')}>TACTICS</Button>
                                    <Button className="w-64 py-4 text-xl" onClick={() => setView('RANK_SELECT')}>BATTLE</Button>
                                </div>
                            </div>
                        )}
                        {view === 'ASSEMBLE' && <AssembleScreen currentParts={currentParts} setPart={(s, p) => setCurrentParts(prev => ({...prev, [s]: p}))} onBack={() => setView('HOME')} />}
                        {view === 'TACTICS' && <TacticsScreen aiSettings={aiSettings} setAiSettings={setAiSettings} onBack={() => setView('HOME')} />}
                        {view === 'RANK_SELECT' && (
                            <div className="flex flex-col items-center justify-center h-full space-y-4 bg-gray-900">
                                <h2 className="text-3xl text-cyan-500 tech-font mb-8">SELECT LEAGUE</h2>
                                {RANKS.map(r => (
                                    <button key={r.id} onClick={() => { setSelectedRank(r); setView('BATTLE'); }} className="w-96 p-6 border border-gray-700 bg-black/50 hover:border-cyan-500 hover:bg-cyan-900/20 text-left transition-all">
                                        <div className="text-2xl tech-font text-white">{r.name}</div>
                                        <div className="text-sm text-gray-500 mt-1">PRIZE: {r.prize} C</div>
                                    </button>
                                ))}
                                <Button variant="secondary" onClick={() => setView('HOME')} className="mt-8">RETURN</Button>
                            </div>
                        )}
                        {view === 'BATTLE' && selectedRank && <BattleScreen playerParts={currentParts} playerAi={aiSettings} enemyData={ENEMIES[selectedRank.enemyId]} onFinish={handleFinish} />}
                        {view === 'RESULT' && (
                            <div className="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center">
                                <h2 className={`text-5xl tech-font mb-6 ${lastResult ? 'text-cyan-400' : 'text-red-600'}`}>{lastResult ? 'VICTORY' : 'DEFEAT'}</h2>
                                <Button onClick={() => setView('HOME')} className="w-48 py-3">RETURN TO BASE</Button>
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
